# Created On: 8/25/2018 3:21 AM
# Created By: Nathan Swift nate.swift@live.com
# Updated By: Roberto Mardeni roberto.mardeni@microsoft.com
# This script is as is and not supported by Microsoft 
# Microsoft does not assume any risk of data loss
# Use it at your own risk
################################################################################

<# 
Current Services:

PaaS SQL DB
PaaS MySQL DB
PaaS PostgreSQL DB
Cosmos DB
Functions
Storage Account
TrafficManager
KeyVault
AzureDataLakeStore
AzureDataLakeAnalytics
Redis Cache
App Service
App Service Enviroment
Service Fabric - InProgress
Batch
ServiceBus
EventHubs
IOT Hub
API Management
Automation
Public IP
Search
Analysis Services
Logic App
CDN
HDInsights
ACI
ACR
#>

<#  Possible Futures:
 
 1. Expand more services with endpoints to scope, like AKS and ServiceFabric.
 2. Expand URLs on AppServices
 3. Add column in report for Admin username
 4. Use crowbar or some utility to brute force 3389 pip to test for weak user\pass - ARM deploy SF,Batch,Automation, or ACI
 5. Other PenTesting Automation ?
 6. Write Out How to update script for services

 #>
 param(
    ## Optional, if not provided will use all subscriptions
    [string]$SubscriptionId,
    [string]$OutputDirectory = "C:\Temp",
    [boolean]$PreservePriorOutput = $true
  )
  
  $ErrorActionPreference = "Stop"
  
  #create temp dir
  New-Item -ItemType Directory -Force -Path $OutputDirectory | Out-Null
  
  # Path and filename for output data file being generated.
  $scopepath = -join ($OutputDirectory, "\scope.txt")
  $outputpath = -join ($OutputDirectory, "\output.csv")
  
  # Time Tracking Start
  $datetimestart = Get-Date
  Write-Host $scopepath
  
  #Check if a scope file already exists
  $scopeFileExists = Test-Path -Path $scopepath
  
  if ($scopeFileExists) {
    if ($PreservePriorOutput) {
      Rename-Item -Path $scopepath -NewName ("scope." + $datetimestart.ToFileTime().ToString() + ".txt")
      Write-host "Renamed Previous Scope File"    
    }
    else {
      Remove-Item -Path $scopepath
      Write-host "Removed Previous Scope File"    
    }
  }
  
  #Check if an ouput file already exists
  $outputFileExists = Test-Path -Path $outputpath
  
  if ($outputFileExists) {
    if ($PreservePriorOutput) {
      Rename-Item -Path $outputpath -NewName ("output." + $datetimestart.ToFileTime().ToString() + ".csv")
      Write-host "Renamed Previous Output File"    
    }
    else {
      Remove-Item -Path $outputpath
      Write-host "Removed Previous Output File"    
    }
  }
  
  # Authenticate Piece
  # There are many ways to authenticate in a non interactive and automated fashion, please adapt your needs accordingly. 
  Login-AzureRmAccount
  
  # Collect all subscriptions or a single subscription if param SubscriptionID was used
  if ($SubscriptionId -match "-") {
    $subs = Get-AzureRmSubscription | Where-Object { $_.SubscriptionId -eq $SubscriptionId }
  }
  else {
    $subs = Get-AzureRmSubscription
  }
  
  # Outputfile for azure inventory
  $outputFile = $scopepath
  
  #Set and apply 1st line of csv headers
  $scopestring = "Subscription,ResourceGroupName,Type,ResourceName,URLs"
  $scopestring | Out-File $outputFile -append -force
  
  # Iterate through all subscriptions
  foreach ($sub in $subs) {
  
    # Set the current  Azure Subscription to pull information from
    Set-AzureRmContext -Subscription $sub.Name | Out-Null
  
    #Collect all resources in current context Subscription
    $Resources = Get-AzureRmResource -ExpandProperties
  
    # Loop and iterate through all VMs to begin collecting data
    foreach ($Resource in $Resources) {
  
      # Type of Azure resource
      $RGName = $Resource.ResourceGroupName
      $Name = $Resource.name
      $Type = $Resource.resourcetype
  
      # Set variable $URL to NOTSET to prevent azure services that do not contain public enpoint from being written into scope report.
      $URL = "NOTSET"
  
      ## Utility function to write the scope out
      function Write-Scope {
        param ([string]$URL)
        if ($URL) {
          $scopestring = "$($sub.Name),$RGName,$Type,$Name,$URL"
          $scopestring | Out-File $outputFile -append -force
        }
      }
  
      try {
          
        switch -Regex ($Type) {
          ## Storage Accounts
          "Microsoft.Storage/storageAccounts$" {
            #storage accounts are weird, so we have to wire the output up differently
            "blob", "file", "queue", "table" | ForEach-Object {
              Write-Scope "$Name.$_.core.windows.net"
            }; break
          }
          ## SQL
          "Microsoft.Sql/servers$" { Write-Scope $Resource.Properties.fullyQualifiedDomainName; break }
          ## PostgreSQL
          "Microsoft.DBforPostgreSQL/servers$" { Write-Scope $Resource.Properties.fullyQualifiedDomainName; break }
          ## MySQL
          "Microsoft.DBforMySQL/servers$" { Write-Scope $Resource.Properties.fullyQualifiedDomainName; break }
          ## ACR
          "Microsoft.ContainerRegistry/registries$" { Write-Scope $Resource.Properties.loginServer; break }
          ## ACI
          "Microsoft.ContainerInstance/containerGroups$" { 
            $URL = $Resource.Properties.ipAddress.ip
            If ($Resource.Properties.ipAddress.fqdn -cmatch "azurecontainer.io" ) {
              $URL = $Resource.Properties.ipAddress.fqdn
            }
            Write-Scope $URL
            break 
          }
          ## Functions
          "Microsoft.Web/sites/functions$" { Write-Scope $Resource.Properties.hostNames; break }
          ## CosmosDB
          "Microsoft.DocumentDB/databaseAccounts$" {
            Write-Scope $Resource.Properties.documentEndpoint
            Write-Scope $Resource.Properties.tableEndpoint
            Write-Scope $Resource.Properties.gremlinEndpoint
            break
          }
          ## Traffic Manager
          "Microsoft.Network/trafficmanagerprofiles$" { Write-Scope ($Resource.Name + ".trafficmanager.net"); break }
          ## Key Vault
          "Microsoft.KeyVault/vaults$" { Write-Scope $Resource.Properties.vaultUri; break }
          ## DataLake
          "Microsoft.DataLakeStore/accounts$" { Write-Scope $Resource.Properties.endpoint; break }
          ## DataLake Store
          "Microsoft.DataLakeAnalytics/accounts/DataLakeStoreAccounts$" { Write-Scope $Resource.Properties.endpoint; break }
          ## Redis
          "Microsoft.Cache/Redis$" { 
            $port = $Resource.Properties.sslport
            If ($Resource.Properties.EnableNonSslPort) {
              $port = $Resource.Properties.port
            }
            Write-Scope ($Resource.Properties.hostName + ":" + $port)
            break 
          }
          ## Web Apps & App Service Environment
          "Microsoft.Web/sites$" { Write-Scope $Resource.Properties.hostNames; break }
          ## Service Fabric
          "Microsoft.ServiceFabric/clusters$" { Write-Scope $Resource.Properties.clusterEndpoint; break }
          ## Batch
          "Microsoft.Batch/batchAccounts$" { Write-Scope $Resource.Properties.accountEndpoint; break }
          ## Machine Learning
          ## Investigate further their is a swagger def file, maybe some other url service endpoint ?
          ## https://{location}.services.azureml.net/subscriptions/{subscriptionguid}/services/{id}/swagger.json
          ## "Microsoft.MachineLearning/webServices$" { Write-Scope ($Resource.Name + ".services.azureml.net"); break }
          ## Service Bus
          "Microsoft.ServiceBus/namespaces$" { Write-Scope $Resource.Properties.serviceBusEndpoint; break }
          ## Event Hub
          "Microsoft.EventHub/namespaces$" { Write-Scope $Resource.Properties.serviceBusEndpoint; break }
          ## IoT Hub
          "Microsoft.Devices/IotHubs$" { Write-Scope $Resource.Properties.hostName; break }
          ## API Management
          "Microsoft.ApiManagement/service$" { 
            Write-Scope $Resource.Properties.gatewayUrl
            Write-Scope $Resource.Properties.gatewayRegionalUrl
            Write-Scope $Resource.Properties.portalUrl
            Write-Scope $Resource.Properties.managementApiUrl
            break 
          }
          ## Automation
          "Microsoft.Automation/automationAccounts$" { Write-Scope $Resource.Properties.RegistrationUrl; break }
          ## Public IPs
          "Microsoft.Network/publicIPAddresses$" { 
            $URL = $Resource.Properties.ipAddress
            If ($Resource.Properties.dnsSettings.Fqdn -cmatch "cloudapp.azure.com" ) {
              $URL = $Resource.Properties.dnsSettings.Fqdn
            }
            Write-Scope $URL; break 
          }
          ## Search
          "Microsoft.Search/searchServices$" { Write-Scope ($Resource.Name + ".search.windows.net"); break }
          ## Analysis Services
          "Microsoft.AnalysisServices/servers$" { Write-Scope $Resource.Properties.serverFullName; break }
          ## Integration Accounts
          "Microsoft.Logic/integrationAccounts$" { Write-Scope $Resource.Properties.accessEndpoint; break }
          ## CDN
          "Microsoft.Cdn/profiles/endpoints$" { Write-Scope $Resource.Properties.hostName; break }
          ## HD Insight
          "Microsoft.HDInsight/clusters$" { 
            $Resource.Properties.connectivityEndpoints | ForEach-Object {
              Write-Scope ($_.location + ":" + $_.port)
            }; break 
          }
          ## AKS
          "Microsoft.ContainerService/managedClusters$" { Write-Scope $Resource.Properties.fqdn; break }
        }
      } Catch [Exception] {
          Write-Error "An error occurred: $_"
      }
    } #foreach($Resource in $Resources) 
  } #foreach($sub in $subs)
  
  # Time Tracking Finished
  $datetimeend = Get-Date
  Write-Host "Started on $datetimestart"
  Write-Host "Finished on $datetimeend"
  
  # Once done import the data into excel
  Import-Csv -Path $scopepath | Export-Csv -Path $outputpath -NoTypeInformation
